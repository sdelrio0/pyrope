<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/associations.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/sdelrio0/pyrope.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-all">all</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-count">count</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-create">create</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-destroy">destroy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-findByIndex">findByIndex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-first">first</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-last">last</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-take">take</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-update">update</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-associate">associate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dissociate">dissociate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getAssociations">getAssociations</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ddb">ddb</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ddbClient">ddbClient</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-decreaseCounter">decreaseCounter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-increaseCounter">increaseCounter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-buildAction">buildAction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-buildUpdateExpression">buildUpdateExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-genTableDigest">genTableDigest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-iterateArrayOverPromise">iterateArrayOverPromise</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-sha256">sha256</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/associations.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">
import { findByIndex, create, destroy } from &apos;./actions&apos;;
import { difference, intersection, isObject, isArray, isBoolean, isString, pluck } from &apos;underscore&apos;;
import { ddbClient } from &apos;./core&apos;;
import { iterateArrayOverPromise, buildAction } from &apos;./utils&apos;;

const DEBUG = false;

const log = (msg) =&gt; {if(DEBUG)console.log(msg)};

/**
 * Creates associations between entities
 *
 * Handles 1:1, 1:N and N:N associations.
 * (!) Does not check for the existence of the items.
 *
 * ```
 * opts = {
 *   tableName: String,
 *   items: [
 *     {
 *       index: {[indexName]: &apos;123&apos;}, // Can specify multiple values to associate
 *       [hasMany: Boolean = false]   // Used to specify 1:N and 1:N associations
 *     }
 *   ]
 * }
 * ```
 *
 * @param {Object} opts The options object.
 * @return {Boolean|Promise} Resolves to true if successful, throws otherwise
 * @todo: use batchWriteItem and handle unprocessedItems
 *
 */
export const associate = ( opts ) =&gt; {
  if(opts === undefined) return Promise.reject(`associate(): opts should be an object.`);
  
  const { tableName, items } = opts;
  
  // General validations
  if(tableName === undefined || !isString(tableName)) return Promise.reject(`associate(): &apos;tableName&apos; is undefined or not a string.`);
  if(items === undefined || !isArray(items)) return Promise.reject(`associate(): &apos;items&apos; is undefined or not an array.`);
  if(items.length !== 2) return Promise.reject(`associate(): &apos;items&apos; should have 2 elements.`);
  if((items[0].hasMany &amp;&amp; !isBoolean(items[0].hasMany)) || (items[1].hasMany &amp;&amp; !isBoolean(items[1].hasMany))) return Promise.reject(`associate(): &apos;hasMany&apos; should be boolean`);
   
  log(&apos;===========================================&apos;);
  log(`Associating: \n${JSON.stringify(items, null, 2)}`);
   
  // Iterate over the items (max 2)
  return iterateArrayOverPromise(items, (item, prevItemAction = {}, i) =&gt; {
    log(&apos;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&apos;);
    log(`* item[${i}] = ${JSON.stringify(item, null, 2)}`);
    log(`prevItemAction = ${JSON.stringify(prevItemAction, null, 2)}`);
    
    // Item validations
    if(Object.keys(item.index).length !== 1) return Promise.reject(`associate(): &apos;items[${i}].index&apos; should have only 1 key-value pair.`);
    
    const index = item.index;
    const indexKey = Object.keys(index)[0];
    const indexValues = isArray(index[indexKey]) ? index[indexKey] : [index[indexKey]];
    const itemHasMany = item.hasMany;
    
    // log(`itemIndex = ${JSON.stringify(itemIndex, null, 2)}`);
    // log(`itemIndexKey = ${JSON.stringify(itemIndexKey, null, 2)}`);
    // log(`itemIndexValues = ${JSON.stringify(itemIndexValues, null, 2)}`);
    
    // Iterate over each item&apos;s uuids
    return iterateArrayOverPromise(indexValues, (indexValue, prevValueAction = {}) =&gt; {
      const currIndex = {[indexKey]: indexValue};
      
      log(&apos;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&#xB7;&apos;);
      log(`* currIndex = ${JSON.stringify(currIndex, null, 2)}`);
      log(`prevUuidAction: ${JSON.stringify(prevValueAction, null, 2)}`);
      
      // Get the current item&apos;s uuid associations
      return findByIndex({
        tableName,
        index: currIndex
      }).then(itemAssociations =&gt; {
        // Write current item&apos;s uuid if nothing found
        if(itemAssociations === false) {
          log(`No previous associations...`);
          
          // Add the current item&apos;s uuid
          return buildAction(&apos;write&apos;, prevValueAction, prevItemAction, currIndex);
          
        } else {
          if (!isArray(itemAssociations)) itemAssociations = [itemAssociations];
  
          const otherItem = items[1 - i];
          const otherIndex = otherItem.index;
          const otherIndexKey = Object.keys(otherIndex)[0];
          const otherIndexValues = isArray(otherIndex[otherIndexKey]) ? otherIndex[otherIndexKey] : [otherIndex[otherIndexKey]];
          
          const itemAssociatedValues = pluck(itemAssociations, otherIndexKey);
          const alreadyAssociated = intersection(itemAssociatedValues, otherIndexValues);
  
          log(`${JSON.stringify(currIndex)}.hasMany = ${itemHasMany}`);
          log(`${JSON.stringify(currIndex)}.${otherIndexKey}s = ${JSON.stringify(itemAssociatedValues, null, 2)}`);
          log(`${otherIndexKey}.uuids = ${JSON.stringify(otherIndexValues, null, 2)}`);
          log(`alreadyAssociated = ${JSON.stringify(alreadyAssociated, null, 2)}`);
  
          // Preserve these associations
          if(itemHasMany === true) {
            log(`${index}.hasMany: Preserving previous association(s).`);
    
            if(alreadyAssociated.length === otherIndexValues.length) {
              return buildAction(&apos;skip&apos;, prevValueAction, prevItemAction, currIndex);
            } else {
              return buildAction(&apos;write&apos;, prevValueAction, prevItemAction, currIndex);
            }
    
          } else {
            log(`Deleting previous association.`);
            log(`currIndex: ${JSON.stringify(currIndex)}`);
    
            return destroy({
              tableName,
              index: currIndex
            }).then((res) =&gt; {
              if(res === false) return Promise.reject(`Could not destroy association ${JSON.stringify(index)}`);
              
              log(`Destroyed ${JSON.stringify(currIndex)}`);
      
              return buildAction(&apos;write&apos;, prevValueAction, prevItemAction, currIndex);
            })
          }
        }
      })
    }, true).then(action =&gt; {
      // End of uuid iteration
      // todo: Remove this then()
      log(&apos;\nEnd of uuid iteration&apos;);
      log(`Action: ${JSON.stringify(action, null, 2)}`);
      
      if(!isObject(action)) return Promise.reject(`Invalid action, should be object.`);
  
      return action;
    })
  }, true).then(action =&gt; {
    // End of item iteration
    log(&apos;\nEnd of item iteration&apos;);
    log(&apos;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&apos;);
    log(`Action: ${JSON.stringify(action, null, 2)}`);
  
    if(!isObject(action)) return Promise.reject(`Invalid action, should be object.`);
    
    // If there are actions to write...
    if(action.write) {
      action.skip = action.skip ? action.skip : [];
      
      const writeKeys = Object.keys(action.write);
      const skipKeys = difference(Object.keys(action.skip), writeKeys);
      
      log(`writeKeys = ${writeKeys}`);
      log(`skipKeys = ${skipKeys}`);
      
      const writeItems = writeKeys.map(item =&gt; {
        return {index: item, uuids: action.write[item]};
      }).concat(skipKeys.map(item =&gt; {
        return {index: item, uuids: action.skip[item]};
      }));
      
      log(`keys = ${JSON.stringify(writeItems, null ,2)}`);
      
      if(Object.keys(writeItems).length !== 2) return Promise.reject(`Attempting to assign with only one item.`);
       
      log(`\nAbout to write associations...`);
      
      // TODO: Use batchWrite
      // TODO: Critical! Watch for failed requests
      return iterateArrayOverPromise(writeItems[0].uuids, item0uuid =&gt; {
        return iterateArrayOverPromise(writeItems[1].uuids, item1uuid =&gt; {
          return create({
            tableName,
            attributes: {
              [writeItems[0].index]: item0uuid,
              [writeItems[1].index]: item1uuid
            }
          }).then(res =&gt; true)
        }, true)
      }, true)
    } else {
      return false;
    }
  }).catch(err =&gt; Promise.reject(`associate(): ${err}`));
};


/**
 * Dissociates two items if an association is found
 *
 * item[0].uuid should be a scalar
 * item[1].uuid can be an array of associations to remove.
 *
 * ```
 * opts = {
 *   tableName: String,
 *   items: [
 *     {
 *       index: {indexName: any}, // index values should be a scalar
 *     },
 *     {
 *       index: {indexName: [any]}, // index values can be an array
 *     }
 *   ]
 * }
 * ```
 *
 * @param {Object} opts The options object
 * @return {Boolean} true if the association was removed, false if there is no association
 *
 * @todo: Handle unprocessed items. (critical)
 *
 */
export const dissociate = ( opts ) =&gt; {
  if(!isObject(opts)) return Promise.reject(`dissociate(): &apos;opts&apos; should be an object.`);
  
  const { tableName, items } = opts;
  
  let deleteRequests = [];
  
  // Validations
  if(items === undefined || !isArray(items)) return Promise.reject(`dissociate(): &apos;items&apos; is undefined or not an array.`);
  if(tableName === undefined) return Promise.reject(`dissociate(): &apos;tableName&apos; is undefined or not a string.`);
  if(items.length !== 2) return Promise.reject(`dissociate(): &apos;items&apos; should have 2 elements.`);
  if(items[0].index === undefined || items[1].index === undefined) return Promise.reject(`dissociate(): &apos;items&apos; should have an index.`);
  
  const index = items[0].index;
  const indexKey = Object.keys(index)[0];
  const indexValues = index[indexKey];
  
  const otherIndex = items[1].index;
  const otherIndexKey = Object.keys(otherIndex)[0];
  const otherIndexValues =
    otherIndex[otherIndexKey] === null ?
      null :
      isArray(otherIndex[otherIndexKey]) ?
        otherIndex[otherIndexKey] :
        [otherIndex[otherIndexKey]];
  
  if(isArray(indexValues)) return Promise.reject(`dissociate(): items[0] index value (uuid) cannot be an array.`);
  
  log(`Dissociating ${JSON.stringify(opts, null, 2)}`);
    
  return findByIndex({
    tableName,
    index: index
  }).then(res =&gt; {
    if(res === false) return Promise.resolve(false); // No association found
    
    log(`${index}] associations = ${JSON.stringify(res, null, 2)}`);
  
    // Build deleteRequests object
    if(otherIndexValues === null){
      deleteRequests = res.map(currItem =&gt; ({DeleteRequest: {Key: {uuid: currItem.uuid, createdAt: currItem.createdAt}}}));
    } else {
      deleteRequests = res.filter(currItem =&gt; {
        let flag = false;
        
        otherIndexValues.forEach(val =&gt; {
          flag = flag || (currItem[otherIndexKey] === val)
        });
        
        return flag;
      }).map(currItem =&gt; ({DeleteRequest: {Key: {uuid: currItem.uuid, createdAt: currItem.createdAt}}}));
    }
    
    if(deleteRequests.length === 0) return Promise.resolve(false);
  
    const params = {
      RequestItems: {
        [tableName]: deleteRequests
      }
    };
  
    log(`dissociate params: ${JSON.stringify(params, null, 2)}`);
  
    return ddbClient(&apos;batchWrite&apos;, params)
      .then(res =&gt; {
        if(res.UnprocessedItems &amp;&amp; Object.keys(res.UnprocessedItems).length &gt; 0) return Promise.reject(&apos;dissociate() batch: Warning, unprocessed items.&apos; + JSON.stringify(res.UnprocessedItems, null, 2));
        
        return Promise.resolve(true);
      })
  }).catch(err =&gt; Promise.reject(`dissociate(): ${err}`))
};

/**
 *  Returns the associations of the specified item with respect to another item
 *
 * ```
 *  opts = {
 *    tableName: String,
 *    items: [
 *      {
 *        index: {key: value}
 *      },
 *      {
 *        index: String
 *      }
 *    ]
 *  }
 *  ```
 *
 *  @params {Object} opts The options object.
 *  @return {Promised Array}
 */
export const getAssociations = ( opts ) =&gt; new Promise((resolve, reject) =&gt; {
  if(!isObject(opts)) return reject(`getAssociations(): &apos;opts&apos; should be an object.`);
  
  const { tableName, items } = opts;
  
  if(items === undefined || !isArray(items)) return reject(`getAssociations(): &apos;items&apos; is undefined or not an array.`);
  if(tableName === undefined) return reject(`getAssociations(): &apos;tableName&apos; is undefined or not a string.`);
  if(items.length !== 2) return reject(`getAssociations(): &apos;items&apos; should have 2 elements.`);
  if(!isObject(items[0].index)) return reject(`getAssociations(): items[0].index should be an object.`);
  if(!isString(items[1].index)) return reject(`getAssociations(): items[1].index should be a string.`);
  
  const indexKey = Object.keys(items[0].index)[0];
  const indexValue = items[0].index[indexKey];
  
  findByIndex({
    tableName,
    index: {[indexKey]: indexValue}
  })
    .then(res =&gt; resolve(pluck(res, items[1].index)))
    .catch(err =&gt; reject(`getAssociations(): ${err}`));
});</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.7)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
