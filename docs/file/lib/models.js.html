<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/models.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/sdelrio0/pyrope.git" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/models.js~PyropeModel.html">PyropeModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-all">all</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-count">count</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-create">create</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-destroy">destroy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-findByIndex">findByIndex</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-first">first</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-last">last</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-take">take</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-update">update</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-associate">associate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-dissociate">dissociate</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-getAssociations">getAssociations</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ddb">ddb</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ddbClient">ddbClient</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-decreaseCounter">decreaseCounter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-increaseCounter">increaseCounter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-updateCounter">updateCounter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-buildAction">buildAction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-buildUpdateExpression">buildUpdateExpression</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-genTableDigest">genTableDigest</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-iterateArrayOverPromise">iterateArrayOverPromise</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-sha256">sha256</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/models.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import * as pyrope from &apos;./index&apos;;
import { isArray, isObject, sortBy, find, isString } from &apos;underscore&apos;;
import Inflector from &apos;inflected&apos;;

/**
 * Pyrope Model ORM
 *
 */
export default class PyropeModel {
  static name;
  static humanName;
  static fields;
  static table;
  static validations;
  static defaultQueryKey;
  
  /**
   * PyropeModel#constructor
   *
   * @param {GraphQLObjectType} schema - The model schema.
   * @param {object} opts - The options object.
   * @param {string} opts.name - Custom name.
   * @param {string} opts.humanName - Custom human name (for errors).
   * @param {string} opts.table - Custom table to query from.
   * @param {string} opts.defaultQueryKey - Custom default query key.
   * @param {function(fields: object, fieldName: string)} opts.validations - Validation function.
   */
  constructor(schema, opts = {}) {
    if(!schema) throw new Error(`PyropeModel#constructor(): &apos;schema&apos; is undefined.`);
    if(!schema.name) throw new Error(&apos;PyropeModel#constructor(): schema.name is undefined.&apos;);
    if(!schema._typeConfig.fields) throw new Error(&apos;PyropeModel#constructor(): schema.fields is undefined.&apos;);
    
    this.name = opts.name || schema.name;
    this.humanName = opts.humanName || Inflector.humanize(this.name);
    this.table = opts.table || Inflector.tableize(schema.name);
    this.fields = schema._typeConfig.fields();
    this.defaultQueryKey = opts.defaultQueryKey || &apos;uuid&apos;;
    this.validations = opts.validations;
  }
  
  /**
   * Retrieve a record given an index
   *
   * @param {object} index - The index used to find the record.
   * @param {string} index.key - The index key used to query the record.
   * @param {string} index.value - The index value used to query the record.
   * @returns {Promise&lt;Map, Promise.reject&gt;} - The retrieved record map. Rejects if record is not found.
   */
  get(index) {
    return new Promise((resolve, reject) =&gt; {
      if(!index || !isObject(index)) return reject(`PyropeModel#get(): &apos;index&apos; is undefined or not an object.`)
      pyrope.findByIndex({
        tableName: this.table,
        index
      })
        .then(records =&gt; {
          if(records === false) {
            reject(`${this.humanName} not found.`);
          } else if(isArray(records) &amp;&amp; records.length &gt; 1) {
            reject(&apos;PyropeModel.get(): More than one item with the specified index were found.&apos;);
          } else {
            resolve(records[0])
          }
        })
        .catch(err =&gt; reject(`PyropeModel#get() &gt; ${err}`));
    });
  }
  
  /**
   * Get all records
   *
   * @param {object} opts - Options object.
   * @param {string} opts.ascending - Options object.
   * @param {number} opts.limit - The amount of records to retrieve.
   * @param {string} opts.cursor - The cursor from which the query continues.
   * @returns {Promise&lt;Array&gt;} - An array with the maps of the retrieved objects. Empty array if none is found.
   */
  getAll(opts = {}) {
    return new Promise((resolve, reject) =&gt; {
      const optsAll = {
        ascending: (opts.order &amp;&amp; opts.order === &apos;asc&apos; ? true : (opts.order &amp;&amp; opts.order === &apos;desc&apos; ? false : true)),
        limit: (opts.limit || 0),
        cursor: (opts.cursor || undefined),
      };
  
      pyrope.all({
        tableName: this.table,
        ...optsAll
      })
        .then(records =&gt; {
          if(records.Cursor) {
            records.Items[records.Items.length-1].cursor = records.Cursor; // assign cursor to the last item
          }
      
          resolve(records.Items)
        })
        .catch(err =&gt; reject(`PyropeModel#getAll() &gt; ${err}`));
    });
  }
  
  /**
   * Create a record
   *
   *
   *
   * @param opts
   * @returns {Promise}
   */
  create(fields = {}, opts = {}) {
    return new Promise((resolve, reject) =&gt; {
      if(!fields || !isObject(fields)) return reject(`PyropeModel#create(): &apos;fields&apos; is undefined or not an object.`);
      
      const {
        beforeValidation,
        afterValidation,
        beforeCreate,
        afterCreate,
        fieldName
      } = opts;
      
      const emptyHook = (fields) =&gt; new Promise((resolve, reject) =&gt; resolve(fields));
      const createHook = (fields, fieldName) =&gt; new Promise((res, rej) =&gt; {
        pyrope.findByIndex({
          tableName: this.table,
          index: {[this.defaultQueryKey]: fields[this.defaultQueryKey]}
        })
          .then(exists =&gt; {
            if(exists !== false) {
              return reject(`${this.humanName} already exists.`);
            }
          })
          .then(() =&gt; pyrope.create({
            tableName: this.table,
            attributes: fields
          }))
          .then(record =&gt; res(record))
          .catch(err =&gt; rej(`createHook() &gt; ${err}`));
      });
  
      let hookChain = [];
      
      hookChain.push(beforeValidation || emptyHook);
      hookChain.push(this.validations || emptyHook);
      hookChain.push(afterValidation  || emptyHook);
      hookChain.push(beforeCreate     || emptyHook);
      hookChain.push(createHook);
      hookChain.push(afterCreate      || emptyHook);
  
      hookChain.reduce((prevPromise, currPromise) =&gt; prevPromise
        .then(res =&gt; currPromise(res, fieldName)), Promise.resolve(fields))
        .then(res =&gt; resolve(res))
        .catch(err =&gt; reject(`PyropeModel#create() &gt; ${err}`));
    });
  }
  
  update(index, fields = {}, opts = {}) {
    return new Promise((resolve, reject) =&gt; {
      if(!index || !isObject(index)) return reject(`PyropeModel#update(): &apos;index&apos; is undefined or not an object.`);
      if(fields &amp;&amp; !isObject(fields)) return reject(`PyropeModel#update(): &apos;fields&apos; is not an object.`);
  
      const {
        beforeValidation,
        afterValidation,
        beforeUpdate,
        afterUpdate,
        fieldName
      } = opts;
  
      const emptyHook = (fields) =&gt; new Promise((resolve, reject) =&gt; resolve(fields));
      const updateHook = (fields) =&gt; new Promise((res, rej) =&gt; {
        pyrope.update({
          tableName: this.table,
          index,
          attributes: fields
        })
          .then(record =&gt; {
            if(record === false) {
              return rej(`${this.humanName} not found.`);
            } else {
              const indexKey = Object.keys(index)[0];
              const newIndex = {
                [indexKey]: record[indexKey]
              };
        
              return res(this.get(newIndex))
            }
          })
          .catch(err =&gt; reject(`updateHook() &gt; ${err}`));
      });
      
      let hookChain = [];
  
      hookChain.push(beforeValidation || emptyHook);
      hookChain.push(this.validations || emptyHook);
      hookChain.push(afterValidation  || emptyHook);
      hookChain.push(beforeUpdate     || emptyHook);
      hookChain.push(updateHook);
      hookChain.push(afterUpdate      || emptyHook);
  
      hookChain.reduce((prevPromise, currPromise) =&gt; prevPromise
        .then(res =&gt; currPromise(res, fieldName, index)), Promise.resolve(fields))
        .then(res =&gt; resolve(res))
        .catch(err =&gt; reject(`PyropeModel#update() &gt; ${err}`));
    });
  }
  
  destroy(index, opts = {}) {
    return new Promise((resolve, reject) =&gt; {
      if(!index || !isObject(index)) return reject(`PyropeModel#destroy(): &apos;index&apos; is undefined or not an object.`);
    
      const {
        beforeValidation,
        afterValidation,
        beforeDestroy,
        afterDestroy,
        fieldName
      } = opts;
    
      const emptyHook = (fields) =&gt; new Promise((resolve, reject) =&gt; resolve(fields));
      const deleteHook = (fields) =&gt; new Promise((res, rej) =&gt; {
        pyrope.destroy({
          tableName: this.table,
          index
        })
          .then(record =&gt; {
            if(record === false) {
              return rej(`${this.humanName} not found.`);
            } else {
              return res(record)
            }
          })
          .catch(err =&gt; reject(`destroyHook() &gt; ${err}`));
      });
    
      let hookChain = [];
    
      hookChain.push(beforeValidation || emptyHook);
      hookChain.push(this.validations || emptyHook);
      hookChain.push(afterValidation  || emptyHook);
      hookChain.push(beforeDestroy    || emptyHook);
      hookChain.push(deleteHook);
      hookChain.push(afterDestroy     || emptyHook);
    
      hookChain.reduce((prevPromise, currPromise) =&gt; prevPromise
        .then(res =&gt; currPromise(res, fieldName, index)), Promise.resolve(this.get(index)))
        .then(res =&gt; resolve(res))
        .catch(err =&gt; reject(`PyropeModel#destroy() &gt; ${err}`));
    });
  }
  
  /**
   * Get a child (1:1)
   *
   * @param {string} uuid - The index value to query the parent.
   * @param {string} childIndexKey - The index key used to query the child.
   * @param {function(source: object)} childResolver - Resolver function.
   * @param {object} opts - The options object.
   * @param {string} opts.table - Custom association table to query from.
   * @returns {Promise&lt;Map, null&gt;} - null if not found
   */
  getChild(uuid, childIndexKey, childResolver, opts = {}) {
    return new Promise((resolve, reject) =&gt; {
      if(!uuid) return reject(`PyropeModel#getChild(): &apos;uuid&apos; is undefined.`);
      
      if(!childIndexKey || !isString(childIndexKey)) return reject(`PyropeModel#getChild(): &apos;childIndexKey&apos; is undefined or not a string.`);
  
      const parentIndexKey = Inflector.underscore(Inflector.singularize(this.name));
      childIndexKey = Inflector.underscore(Inflector.singularize(childIndexKey));
      const tableName = opts.table || this.buildAssociationTableName(childIndexKey);
      
      pyrope.getAssociations({
        tableName: tableName,
        items: [
          {index: {[parentIndexKey]: uuid}},
          {index: childIndexKey}
        ]
      })
        .then(associations =&gt; {
          if(associations.length &gt; 1) {
            reject(`PyropeModel#getChild(): Expected only one association.`);
          } else if(associations.length === 0) {
            resolve(null);
          } else {
            return childResolver({uuid: associations[0]})
          }
        })
        .then(record =&gt; resolve(record))
        .catch(err =&gt; reject(`PyropeModel#getChild() &gt; ${err}`))
    });
  }
  
  buildItemIndices(uuid, childIndex) {
    if(!uuid) throw new Error(`&apos;uuid&apos; is undefined.`);
    if(!childIndex || !isObject(childIndex)) throw new Error(`&apos;index&apos; is undefined or not an object.`);
    if(Object.keys(childIndex).length &gt; 1) throw new Error(`&apos;index&apos; should have only one key-value pair.`);
  
    const childIndexKey = Inflector.underscore(Inflector.singularize(Object.keys(childIndex)[0]));
    // const childIndexValue = childIndex[childIndexKey];
    const parentIndexKey = Inflector.underscore(Inflector.singularize(this.name));
    const parentIndexValue = uuid;
  
    if(!Object.keys(this.fields).find(f =&gt; f === childIndexKey)) throw new Error(`&apos;${childIndexKey}&apos; is not a field of &apos;${this.name}&apos;.`);
    if(!this.fields[childIndexKey].type) throw new Error(`&apos;${childIndexKey}&apos; is missing type.`);
    if(!this.fields[childIndexKey].type._typeConfig) throw new Error(`&apos;${childIndexKey}.type&apos; is missing _typeConfig.`);
    if(!this.fields[childIndexKey].type._typeConfig.fields) throw new Error(`&apos;${childIndexKey}&apos; is missing fields.`);
    if(!(Object.keys(this.fields[childIndexKey].type._typeConfig.fields()).find(f =&gt; f === parentIndexKey ))) throw new Error(`&apos;${childIndexKey}&apos; is missing field &apos;${parentIndexKey}&apos;.`);
  
  
    const childFields = this.fields[childIndexKey].type._typeConfig.fields();
    const parentFields = this.fields;
    const childHasManyParents = childFields[parentIndexKey].hasMany || false;
    const parentHasManyChildren = parentFields[childIndexKey].hasMany || false;
  
    const parentIndex = {[parentIndexKey]: parentIndexValue};
    
    return [
      {
        index: parentIndex,
        hasMany: parentHasManyChildren,
      },
      {
        index: childIndex,
        childHasManyParents
      }
    ];
  }
  
  buildAssociationTableName(associationKey) {
    return sortBy([this.name, associationKey].map(t =&gt; Inflector.tableize(t)), t =&gt; t).join(&apos;_&apos;);
  }
  
  /**
   *
   * @param uuid
   * @param childIndex
   * @param opts
   * @returns {Promise}
   */
  setChild(uuid, childIndex, opts = {}) {
    return new Promise((resolve, reject) =&gt; {
      if(!uuid) return reject(`PyropeModel#setChild(): &apos;uuid&apos; is undefined.`);
      if(!childIndex || !isObject(childIndex)) return reject(`PyropeModel#setChild(): &apos;index&apos; is undefined or not an object.`);
      if(Object.keys(childIndex).length &gt; 1) return reject(`PyropeModel#setChild(): &apos;index&apos; should have only one key-value pair.`);
  
      const childIndexKey = Inflector.underscore(Inflector.singularize(Object.keys(childIndex)[0]));
      
      let items;
      
      try {
        items = this.buildItemIndices(uuid, childIndex);
      } catch(err) {
        return reject(`PyropeModel#setChild() &gt; ${err}`);
      }
      
      const tableName = opts.table || this.buildAssociationTableName(childIndexKey);
      
      pyrope.associate({tableName, items})
        .then(() =&gt; resolve(true))
        .catch(err =&gt; reject(`PyropeModel#setChild() &gt; ${err}`))
    });
  }
  
  /**
   *
   * @param uuid
   * @param childIndexKey
   * @param opts
   * @returns {Promise} -
   */
  unsetChild(uuid, childIndexKey, opts = {}) {
    return new Promise((resolve, reject) =&gt; {
      if(!uuid) return reject(`PyropeModel#unsetChild(): &apos;uuid&apos; is undefined.`);
      if(!childIndexKey || !isString(childIndexKey)) return reject(`PyropeModel#getChild(): &apos;childIndexKey&apos; is undefined or not a string.`);
    
      childIndexKey = Inflector.underscore(Inflector.singularize(childIndexKey));
  
      const parentIndexKey = Inflector.underscore(Inflector.singularize(this.name));
      const parentIndexValue = uuid;
      const tableName = opts.table || this.buildAssociationTableName(childIndexKey);
      
      
      pyrope.getAssociations({
        tableName: tableName,
        items: [
          {index: {[parentIndexKey]: parentIndexValue}},
          {index: childIndexKey}
        ]
      })
        .then(associations =&gt; {
          if(associations.length &gt; 1) {
            reject(`PyropeModel#unsetChild(): Expected only one association.`);
          } else if(associations.length === 0) {
            return Promise.resolve(true);
          } else {
            return Promise.resolve(associations[0]);
          }
        })
        .then(assoc =&gt; {
          if(assoc === true) {
            return Promise.resolve(assoc);
          } else {
            return pyrope.dissociate({
              tableName: tableName,
              items: [
                {index: {[parentIndexKey]: parentIndexValue}},
                {index: {[childIndexKey]: assoc}}
              ]
            })
          }
        })
        .then((res) =&gt; resolve(res))
        .catch(err =&gt; reject(`PyropeModel#unsetChild(): ${err}`))
    });
  };
  
  getChildren() {
    
  }
  
  setChildren() {
    
  }
  
  unsetChildren() {
    
  }
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.4.7)</span></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
